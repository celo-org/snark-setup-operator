diff --git a/src/bin/contribute.rs b/src/bin/contribute.rs
index 6e0f34b..ae3d6e3 100644
--- a/src/bin/contribute.rs
+++ b/src/bin/contribute.rs
@@ -81,7 +81,7 @@ pub struct ContributeOpts {
     pub phase: Option<String>,
     #[options(
         help = "the url of the coordinator API",
-        default = "https://plumo-setup-phase-1.azurefd.net"
+        default = "https://plumo-setup-phase-2.azurefd.net"
     )]
     pub coordinator_url: String,
     #[options(
diff --git a/src/bin/control.rs b/src/bin/control.rs
index 5a30b96..e21102d 100644
--- a/src/bin/control.rs
+++ b/src/bin/control.rs
@@ -657,7 +657,7 @@ impl Control {
                 COMBINED_VERIFIED_POK_AND_CORRECTNESS_NEW_CHALLENGE_FILENAME,
                 COMBINED_VERIFIED_POK_AND_CORRECTNESS_NEW_CHALLENGE_HASH_FILENAME,
                 SubgroupCheckMode::Auto,
-                false,
+                false, // ratio check
                 &parameters,
             );
             phase1_cli::transform_ratios(
diff --git a/src/bin/new_ceremony.rs b/src/bin/new_ceremony.rs
index e954e00..099ace7 100644
--- a/src/bin/new_ceremony.rs
+++ b/src/bin/new_ceremony.rs
@@ -141,6 +141,7 @@ async fn run<E: PairingEngine>(opts: &NewCeremonyOpts, private_key: &[u8]) -> Re
     let upload_mode = upload_mode_from_str(&opts.upload_mode)?;
     let proving_system = proving_system_from_str(&opts.proving_system)?;
     let chunk_size = 1 << opts.chunk_size;
+    println!("chunk_size new challenge: {}", chunk_size);
     let parameters = Phase1Parameters::<E>::new_chunk(
         ContributionMode::Chunked,
         0,
@@ -161,7 +162,7 @@ async fn run<E: PairingEngine>(opts: &NewCeremonyOpts, private_key: &[u8]) -> Re
             NEW_CHALLENGE_FILENAME,
             NEW_CHALLENGE_HASH_FILENAME,
             NEW_CHALLENGE_LIST_FILENAME,
-            opts.chunk_size,
+            chunk_size,
             &opts
                 .phase1_filename
                 .as_ref()
diff --git a/src/bin/verify_transcript.rs b/src/bin/verify_transcript.rs
index ca495dd..a564970 100644
--- a/src/bin/verify_transcript.rs
+++ b/src/bin/verify_transcript.rs
@@ -87,9 +87,11 @@ pub struct VerifyTranscriptOpts {
     pub skip_ratio_check: bool,
     #[options(help = "curve", default = "bw6")]
     pub curve: String,
-
+    #[options(help = "the round at which full checks begin", default = "0")]
+    pub round_threshold: u64,
     #[options(help = "size of chunks used")]
     pub chunk_size: Option<usize>,
+
     #[options(help = "number max validators used in the circuit. Only used for phase 2")]
     pub num_validators: Option<usize>,
     #[options(help = "number max epochs used in the circuit. Only used for phase 2")]
@@ -115,6 +117,7 @@ pub struct TranscriptVerifier {
     pub batch_exp_mode: BatchExpMode,
     pub subgroup_check_mode: SubgroupCheckMode,
     pub ratio_check: bool,
+    pub round_threshold: u64,
     pub phase2_options: Option<Phase2Options>,
 }
 
@@ -202,6 +205,7 @@ impl TranscriptVerifier {
             batch_exp_mode: opts.batch_exp_mode,
             subgroup_check_mode: opts.subgroup_check_mode,
             ratio_check: !opts.skip_ratio_check,
+            round_threshold: opts.round_threshold,
             phase2_options,
         };
         Ok(verifier)
@@ -268,11 +272,13 @@ impl TranscriptVerifier {
                     .phase2_options
                     .as_ref()
                     .expect("Phase2 options not used while running phase2 verification");
+                let chunk_size = 1 << phase2_options.chunk_size;
+                println!("chunk_size verify: {}", chunk_size);
                 phase2_cli::new_challenge(
                     NEW_CHALLENGE_FILENAME,
                     NEW_CHALLENGE_HASH_FILENAME,
                     NEW_CHALLENGE_LIST_FILENAME,
-                    phase2_options.chunk_size,
+                    chunk_size,
                     &phase2_options.phase1_filename,
                     phase2_options.phase1_powers,
                     &phase2_options.circuit_filename,
@@ -422,7 +428,11 @@ impl TranscriptVerifier {
                     ))?;
 
                     // Run verification between challenge and response, and produce the next new
-                    // challenge.
+                    // challenge. Skip both subgroup and ratio checks if below round threshold.
+                    let (subgroup_check, ratio_check) = match round_index < self.round_threshold {
+                        true => (SubgroupCheckMode::No, false),
+                        false => (self.subgroup_check_mode, self.ratio_check),
+                    };
                     if self.phase == Phase::Phase1 {
                         phase1_cli::transform_pok_and_correctness(
                             CHALLENGE_FILENAME,
@@ -439,8 +449,8 @@ impl TranscriptVerifier {
                             ),
                             NEW_CHALLENGE_FILENAME,
                             NEW_CHALLENGE_HASH_FILENAME,
-                            self.subgroup_check_mode,
-                            self.ratio_check,
+                            subgroup_check,
+                            ratio_check,
                             &parameters,
                         );
                     } else {
@@ -459,8 +469,8 @@ impl TranscriptVerifier {
                             ),
                             NEW_CHALLENGE_FILENAME,
                             NEW_CHALLENGE_HASH_FILENAME,
-                            self.subgroup_check_mode,
-                            false,
+                            subgroup_check,
+                            false, // verify full contribution
                         );
                     }
 
